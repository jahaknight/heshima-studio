package com.heshima.heshima_studio.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.heshima.heshima_studio.controller.dto.InquiryItemResponse;
import com.heshima.heshima_studio.controller.dto.InquiryRequest;
import com.heshima.heshima_studio.controller.dto.InquiryResponse;
import com.heshima.heshima_studio.service.InquiryService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Unit test for InquiryController.
 *
 * This test does NOT start the full Spring context.
 * Instead, it:
 *  - creates a real instance of the controller,
 *  - injects a mocked InquiryService,
 *  - and exercises the controller using MockMvc.
 *
 * This style is useful when @MockBean / @WebMvcTest is not available
 * for the current Java/Spring version.
 */
class InquiryControllerTest {

    private MockMvc mockMvc;
    private ObjectMapper objectMapper;

    // This service is what the controller depends on.
    // We mock it so we can control its return values.
    @Mock
    private InquiryService inquiryService;

    @BeforeEach
    void setUp() {
        // Initialize Mockito annotations (@Mock fields)
        MockitoAnnotations.openMocks(this);

        // Create the controller under test and inject the mock service
        InquiryController controller = new InquiryController(inquiryService);

        // Build a standalone MockMvc instance around this controller only
        this.mockMvc = MockMvcBuilders.standaloneSetup(controller).build();

        // Used to convert request objects â†’ JSON
        this.objectMapper = new ObjectMapper();
    }

    @Test
    @DisplayName("POST /api/inquiries returns 201 and response body")
    void createInquiry_returnsCreated() throws Exception {
        // ---------- Arrange ----------

        // Build the request DTO the same way the client/front-end would send it
        InquiryRequest req = new InquiryRequest();
        req.setProductId(1L);
        req.setName("Test Person");
        req.setEmail("test@example.com");
        req.setMessage("hello");

        // Build the response DTO we expect the service to give back
        InquiryItemResponse line = new InquiryItemResponse(
                1L,                    // productId
                "Branding",                     // productName
                1,                              // quantity
                new BigDecimal("750.00")    // finalPrice
        );

        InquiryResponse resp = new InquiryResponse(
                99L,                   // id generated by the system
                "Test Person",
                "test@example.com",
                "hello",
                LocalDateTime.now(),
                List.of(line)
        );

        // Tell the mocked service to return our fake response
        // whenever the controller calls createInquiry(...)
        when(inquiryService.createInquiry(
                any(Long.class),
                any(String.class),
                any(String.class),
                any(String.class)
        )).thenReturn(resp);

        // ---------- Act (when) ----------
        // Perform a POST request against the controller endpoint
        mockMvc.perform(post("/api/inquiries")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                // ---------- Assert (then) ----------
                .andExpect(status().isCreated())
                // Verify JSON body fields
                .andExpect(jsonPath("$.id").value(99))
                .andExpect(jsonPath("$.customerName").value("Test Person"))
                .andExpect(jsonPath("$.items[0].productName").value("Branding"));

    }
}